package JoshuaBloch.Chapter3.Item10.Transitivity;

public class Point {

    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // Instead of the getClass implementation that is generated by Intellij
    // we are going with the instance of method instead.

    // There is a difference between the two.
    // If you compare point.equals(colorPoint), the below implementation is going to return false,
    // because the getClass() of Point is clearly not the same as getClass() of ColorPoint.

    // Broken - violates Liskov substitution principle
//    @Override
//    public boolean equals(Object o) {
//        if (this == o) return true;
//        if (o == null || getClass() != o.getClass()) return false;
//        Point point = (Point) o;
//        return point.x == this.x && point.y == this.y;
//    }

    // However, this implementation will return true for point.equals(colorPoint) comparison
    // because the ColorPoint class extends the Point class. Hence as far as the Point class is concerned,
    // ColorPoint IS AN INSTANCE OF Point class.
    // Also note that when doing instance of check, there is no need to explicitly check for null.
    // Condition 'o == null' covered by subsequent condition '!(o instanceof Point)'
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Point)) return false;
        Point point = (Point) o;
        return point.x == this.x && point.y == this.y;
    }

    @Override
    public int hashCode() {
        int result = x;
        result = 31 * result + y;
        return result;
    }
}

// Suppose you extend the Point class to add the notion of a color to a class as well
class ColorPoint extends Point {

    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    // This implementation will return false for colorPoint.equals(point) comparison.
    // Because, although ColorPoint extends Point,
    // the Point class IS NOT AN INSTANCE OF ColorPoint class.
    // Thus we have achieved non-symmetricity.
//    @Override
//    public boolean equals(Object o) {
//        if (this == o) return true;
//        if (!(o instanceof ColorPoint)) return false;
//        if (!super.equals(o)) return false;
//        ColorPoint that = (ColorPoint) o;
//        return color == that.color;
//    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Point)) return false;

        // If o is a normal Point, do a color-blind comparison
        if (!(o instanceof ColorPoint)){
            return o.equals(this);
        }

        // If o is a ColorPoint, do a full comparison
        if (!super.equals(o)) return false;
        ColorPoint that = (ColorPoint) o;
        return color == that.color;
    }

    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + color.hashCode();
        return result;
    }
}

class TestClass {

    public static void main(String[] args) {
        Point point = new Point(1,2);
        ColorPoint redColorPoint = new ColorPoint(1,2,Color.RED);
        ColorPoint blueColorPoint = new ColorPoint(1,2,Color.BLUE);

        // Now the equals method is symmetric.
        System.out.println("point.equals(redColorPoint): " + point.equals(redColorPoint)); // false
        System.out.println("redColorPoint.equals(point): " + redColorPoint.equals(point)); // false

        // And also transitive
        System.out.println("blueColorPoint.equals(point): " + blueColorPoint.equals(point)); // false
        System.out.println("point.equals(redColorPoint): " + point.equals(redColorPoint)); // false
        System.out.println("blueColorPoint.equals(redColorPoint): " + blueColorPoint.equals(redColorPoint)); // false
    }
}